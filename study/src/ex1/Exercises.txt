1) Sistema de identificação

	Estrutura de dados: array multidimensional de inteiros: array[][][]
	posição 1: uid do processo
	posição 2: uid da mensagem
	posição 3: uid do campo da mensagem
	
	Lógica:
	
	A camada de aplicação inicializa o array e o transfere através de uma mensagem para outras camadas.
	Cada processo de cada camada é responsável por extrair o maior valor do array, considerando a primeira posição.
	Então o processo soma 1 ao valor extraído, seta como seu UID e o devolve para a primeira posição do array.
	A mesma lógica é aplicada para a mensagem, porém considera-se o uid do processo que a envolve.
	Idem para os campos das mensagens.
	
	Formato do UID:
	pos1: define o processo. Exemplo: 1.
	pos1-pos2: define a mensagem. Exemplo: 1-1.
	pos1-pos2-pos3: define o campo da mensagem. Exemplo: 1-1-1.

2) Notações para descrição de módulo e implementação:

	Module:
		Name: IntHandler, instance ih.
		
		Events:
			Request: <ih, Insert | int>: Receive an integer value and save.
			Indication: <ih, Alert | string>: Alert when the sum of integers excedeed a hundred, for each hundred.
		
		Properties:
			IH1: A zero or negative value is not processed.
		
	Implements:
		IntHandler, instance ih
		
		upon <ih, Init> do
			h_excedeed := "";
			sum := 0;
			qtd_eh := 0;
		
		upon event <ih, Insert | int> such
		that int > 0 do
			sum := sum + int;
			qtd_eh := trunc(int / 100);
			while (qtd_eh > 0) do // for statement invert the sequence of display hundreds	
				h_excedeed := string(qtd_eh) + "00";
				trigger<ih, Alert | h_excedeed>;
				qtd_eh--;
		
3) Implementação no Appia

	Executar Run.java presente no pacote list1
	
4) 

The processing of the  Recovery  event should, for
instance, retrieve the relevant state of the process from stable storage before the
processing of other events is resumed.

O modelo falha e recuperação continua existindo, pois é necessário que o processo possa recuperar seu estado relevante
a partir de um armazenamento de dados confiável antes que o processo possa continuar executando. Não basta recuperar seu
estado atual, pressupõe-se que o processo precise refazer alguma tarefa já feita anteriormente para poder continuar executando.

Cenário 1: Memristor possui uma capacidade limitada para os processos em execução
Comportamento 1: O memristor tem o mesmo comportamento da DRAM para orquestrar os programas em execução
Cenário 2: Os limites do Memristor não são atingidos pelo número dos programas em execução
Comportamento 2: O memristor possui o mesmo comportamento da HD para orquestrar os programas em execução

A) A memristor recupera o estado automaticamente e o modelo falha-recupera deixa de fazer sentido.
B) Existe um estado "relevante" que precisa ser armazenado de qualquer forma - a aplicação não pode continuar de onde parou, deve refazer alguma coisa.

5) 

FF1: Se um processo correto p deixa de entregar infinitas mensagens a um processo q, então o processo m enviará infinitas vezes a mensagem até que seja recebida pelo processo q.
Felipe: Se um processo correto p envia infinitas mensagens a um processo q, podendo haver um determinado número de perdas, então o processo q entregará um número infinito de vezes exceto o número de mensagens perdidas



	